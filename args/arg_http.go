package args

import (
	"bufio"
	"fmt"
	"os"
	"strings"
	"text/template"

	"github.com/timurkash/back/files"
)

type Service struct {
	Name    string
	Service string
}

func ArgHttpServer() error {
	dirRead, err := os.Open("api")
	if err != nil {
		return err
	}
	dirFiles, err := dirRead.ReadDir(0)
	if err != nil {
		return err
	}
	temp := template.New("http_server")
	if _, err := temp.Parse(httpServer); err != nil {
		return err
	}
	for _, file := range dirFiles {
		if file.IsDir() {
			name := file.Name()
			service, err := getService(fmt.Sprintf("api/%s/%s.proto", name, name))
			if err != nil {
				return err
			}
			filename := fmt.Sprintf("gen/go/api/%s/%s_http.pb.go", name, name)
			if !files.IsExists(filename) {
				if err := rewriteFile(temp, filename, &Service{
					Name:    name,
					Service: service,
				}); err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func rewriteFile(temp *template.Template, filename string, service *Service) error {
	httpFile, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer httpFile.Close()
	writer := bufio.NewWriter(httpFile)
	defer writer.Flush()
	return temp.Execute(writer, *service)
}

const (
	httpServer = `// Code generated by gek -htp. DO NOT EDIT.

package {{ .Name }}

import (
	http "github.com/go-kratos/kratos/v2/transport/http"
)

type {{ .Service }}HTTPServer interface {
}

func Register{{ .Service }}HTTPServer(s *http.Server, srv {{ .Service }}HTTPServer) {
}

type {{ .Service }}HTTPClient interface {
}

type {{ .Service }}HTTPClientImpl struct {
	cc *http.Client
}

func New{{ .Service }}HTTPClient(client *http.Client) {{ .Service }}HTTPClient {
	return &{{ .Service }}HTTPClientImpl{client}
}
`
)

func getService(filename string) (string, error) {
	file, err := os.Open(filename)
	if err != nil {
		return "", err
	}
	defer file.Close()
	errOut := fmt.Errorf("bad %s file", filename)
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		if strings.HasPrefix(line, "service ") {
			lexemes := strings.Split(line, " ")
			if len(lexemes) < 3 {
				return "", errOut
			}
			return lexemes[1], nil
		}
	}
	return "", fmt.Errorf("bad %s file", filename)
}
